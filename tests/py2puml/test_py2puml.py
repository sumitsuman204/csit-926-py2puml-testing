from io import StringIO
from pathlib import Path
from py2puml.asserts import assert_py2puml_is_file_content, assert_py2puml_is_stringio
from py2puml.asserts import assert_multilines
from typing import Iterable
import string
from py2puml.py2puml import py2puml
from hypothesis import given, settings
import hypothesis.strategies as st
import pytest
from string import ascii_letters, digits
import types
import tempfile
import os, sys
from pathlib import Path
import unittest
from io import StringIO
from unittest.mock import patch
from io import StringIO
from typing import List
import subprocess
import numpy as np
import pandas as pd

CURRENT_DIR = Path(__file__).parent

def test_py2puml_model_on_py2uml_domain():
    '''
    Ensures that the documentation of the py2puml domain model is up-to-date
    '''
    domain_diagram_file_path = CURRENT_DIR.parent.parent / 'py2puml' / 'py2puml.domain.puml'

    assert_py2puml_is_file_content('py2puml/domain', 'py2puml.domain', domain_diagram_file_path)

def test_py2puml_with_heavily_nested_model():
    domain_diagram_file_path = CURRENT_DIR.parent / 'modules' / 'withnestednamespace' / 'tests.modules.withnestednamespace.puml'
    assert_py2puml_is_file_content('tests/modules/withnestednamespace', 'tests.modules.withnestednamespace', domain_diagram_file_path)

def test_py2puml_with_subdomain():
    expected = """@startuml tests.modules.withsubdomain
namespace tests.modules.withsubdomain {
  namespace subdomain.insubdomain {}
  namespace withsubdomain {}
}
class tests.modules.withsubdomain.subdomain.insubdomain.Engine {
  horsepower: int
}
class tests.modules.withsubdomain.subdomain.insubdomain.Pilot {
  name: str
}
class tests.modules.withsubdomain.withsubdomain.Car {
  name: str
  engine: Engine
}
tests.modules.withsubdomain.withsubdomain.Car *-- tests.modules.withsubdomain.subdomain.insubdomain.Engine
footer Generated by //py2puml//
@enduml
"""

    assert_py2puml_is_stringio('tests/modules/withsubdomain/', 'tests.modules.withsubdomain', StringIO(expected))

def test_py2puml_check_if_subdomain_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_check_if_subdomain_returns_iterable(domain_path, domain_module):
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)
    assert all(isinstance(x, str) for x in result)

def test_py2puml_check_if_subdomain_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_subdomain_response_contains_module_name(domain_path, domain_module) -> None:
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = list(py2puml(domain_path, domain_module))
    print(result)
    assert f'@startuml {domain_module}' in "".join(result)
def test_py2puml_contains_module_name_in_response_for_subdomain(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = list(py2puml(domain_path, domain_module))
    assert domain_module in "".join(result)

def test_py2puml_creates_namespaces_for_subdomain(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert "namespace" in "".join(result)

def test_py2puml_contains_module_declaration_for_subdomain(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f"@startuml {domain_module}" in "".join(result)

def test_py2puml_contains_association_declaration_for_subdomain(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withsubdomain"
    domain_module = "tests.modules.withsubdomain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'*--' in "".join(result)

def test_py2puml_with_inherited_constructor():
    expected = """@startuml tests.modules.withinheritedconstructor
namespace tests.modules.withinheritedconstructor {
  namespace metricorigin {}
  namespace point {}
}
class tests.modules.withinheritedconstructor.metricorigin.MetricOrigin {
  unit: str {static}
}
class tests.modules.withinheritedconstructor.point.Origin {
  is_origin: bool {static}
}
class tests.modules.withinheritedconstructor.point.Point {
  x: float
  y: float
}
tests.modules.withinheritedconstructor.point.Origin <|-- tests.modules.withinheritedconstructor.metricorigin.MetricOrigin
tests.modules.withinheritedconstructor.point.Point <|-- tests.modules.withinheritedconstructor.point.Origin
footer Generated by //py2puml//
@enduml
"""
    assert_py2puml_is_stringio('tests/modules/withinheritedconstructor/', 'tests.modules.withinheritedconstructor', StringIO(expected))

def test_py2puml_check_if_inherited_constructor_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_check_if_inherited_constructor_returns_iterable(domain_path, domain_module):
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)
    assert all(isinstance(x, str) for x in result)

def test_py2puml_check_if_inherited_constructor_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_inherited_constructor_response_contains_module_name(domain_path, domain_module) -> None:
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = list(py2puml(domain_path, domain_module))
    print(result)
    assert f'@startuml {domain_module}' in "".join(result)

def test_py2puml_contains_module_name_in_response_for_inherited_constructor(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = list(py2puml(domain_path, domain_module))
    assert domain_module in "".join(result)

def test_py2puml_creates_namespaces_for_inherited_constructor(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert "namespace" in "".join(result)

def test_py2puml_contains_module_declaration_for_inherited_constructor(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f"@startuml {domain_module}" in "".join(result)

def test_py2puml_contains_inheritance_declaration_for_inherited_constructor(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withinheritedconstructor/"
    domain_module = "tests.modules.withinheritedconstructor"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'<|--' in "".join(result)

def test_py2puml_with_nested_namespace():
    expected = """@startuml tests.modules.withnestednamespace
namespace tests.modules.withnestednamespace {
  namespace nomoduleroot.modulechild.leaf {}
  namespace tree {}
  namespace branches.branch {}
  namespace withonlyonesubpackage.underground {
    namespace roots.roots {}
  }
  namespace trunks.trunk {}
}
class tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.CommownLeaf {
  color: int
  area: float
}
class tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.OakLeaf {
  curves: int
}
class tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.PineLeaf {
  length: float
}
class tests.modules.withnestednamespace.tree.Oak {
  trunk: Trunk
  branches: List[OakBranch]
}
class tests.modules.withnestednamespace.branches.branch.OakBranch {
  sub_branches: List[OakBranch]
  leaves: List[OakLeaf]
}
class tests.modules.withnestednamespace.withonlyonesubpackage.underground.roots.roots.Roots {
  mass: float
}
class tests.modules.withnestednamespace.withonlyonesubpackage.underground.Soil {
  humidity: float
}
class tests.modules.withnestednamespace.tree.Tree {
  height: float
  roots_depth: float
  roots: Roots
  soil: Soil
}
class tests.modules.withnestednamespace.trunks.trunk.Trunk {
  height: float
}
tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.CommownLeaf <|-- tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.OakLeaf
tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.CommownLeaf <|-- tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.PineLeaf
tests.modules.withnestednamespace.tree.Oak *-- tests.modules.withnestednamespace.trunks.trunk.Trunk
tests.modules.withnestednamespace.tree.Oak *-- tests.modules.withnestednamespace.branches.branch.OakBranch
tests.modules.withnestednamespace.tree.Tree <|-- tests.modules.withnestednamespace.tree.Oak
tests.modules.withnestednamespace.branches.branch.OakBranch *-- tests.modules.withnestednamespace.branches.branch.OakBranch
tests.modules.withnestednamespace.branches.branch.OakBranch *-- tests.modules.withnestednamespace.nomoduleroot.modulechild.leaf.OakLeaf
tests.modules.withnestednamespace.branches.branch.Branch <|-- tests.modules.withnestednamespace.branches.branch.OakBranch
tests.modules.withnestednamespace.tree.Tree *-- tests.modules.withnestednamespace.withonlyonesubpackage.underground.roots.roots.Roots
tests.modules.withnestednamespace.tree.Tree *-- tests.modules.withnestednamespace.withonlyonesubpackage.underground.Soil
footer Generated by //py2puml//
@enduml
"""
    assert_py2puml_is_stringio('tests/modules/withnestednamespace/', 'tests.modules.withnestednamespace', StringIO(expected))

def test_py2puml_check_if_withnestednamespace_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_check_if_withnestednamespace_returns_iterable(domain_path, domain_module):
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)
    assert all(isinstance(x, str) for x in result)

def test_py2puml_check_if_withnestednamespace_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_withnestednamespace_response_contains_module_name(domain_path, domain_module) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    print(result)
    assert f'@startuml {domain_module}' in "".join(result)
def test_py2puml_contains_module_name_in_response_for_withnestednamespace(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    assert domain_module in "".join(result)

def test_py2puml_creates_namespaces_for_withnestednamespace(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert "namespace" in "".join(result)

def test_py2puml_contains_module_declaration_for_withnestednamespace(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f"@startuml {domain_module}" in "".join(result)

def test_py2puml_contains_inheritance_declaration_for_withnestednamespace(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'<|--' in "".join(result)

def test_py2puml_contains_association_declaration_for_withnestednamespace(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/withnestednamespace/"
    domain_module = "tests.modules.withnestednamespace"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'*--' in "".join(result)

def test_py2puml_with_rootnotincwd():
    expected = """@startuml tests.modules.withrootnotincwd
namespace tests.modules.withrootnotincwd {
  namespace point {}
  namespace segment {}
}
class tests.modules.withrootnotincwd.point.Point {
  x: float
  y: float
}
class tests.modules.withrootnotincwd.segment.Segment {
  a: Point
  b: Point
}
tests.modules.withrootnotincwd.segment.Segment *-- tests.modules.withrootnotincwd.point.Point
footer Generated by //py2puml//
@enduml
"""
    assert_py2puml_is_stringio('tests/modules/withrootnotincwd/', 'tests.modules.withrootnotincwd', StringIO(expected))

def test_py2puml_on_overall_modules():
    expected = """@startuml tests.modules
namespace tests.modules {
  namespace withabstract {}
  namespace withbasictypes {}
  namespace withcomposition {}
  namespace withcompoundtypewithdigits {}
  namespace withconstructor {}
  namespace withenum {}
  namespace withinheritancewithinmodule {}
  namespace withnamedtuple {}
  namespace withsubdomain {
    namespace subdomain.insubdomain {}
    namespace withsubdomain {}
  }
  namespace withwrappedconstructor {}
}
abstract class tests.modules.withabstract.ClassTemplate {
}
class tests.modules.withabstract.ConcreteClass {
}
class tests.modules.withbasictypes.Contact {
  full_name: str
  age: int
  weight: float
  can_twist_tongue: bool
}
class tests.modules.withcomposition.Address {
  street: str
  zipcode: str
  city: str
}
class tests.modules.withcomposition.Firm {
  name: str
  employees: List[Worker]
}
class tests.modules.withcomposition.Worker {
  name: str
  colleagues: List[Worker]
  boss: Worker
  home_address: Address
  work_address: Address
}
class tests.modules.withcompoundtypewithdigits.IPv6 {
  address: str
}
class tests.modules.withcompoundtypewithdigits.Multicast {
  addresses: List[IPv6]
}
class tests.modules.withconstructor.Coordinates {
  x: float
  y: float
}
class tests.modules.withconstructor.Point {
  PI: float {static}
  coordinates: Coordinates
  day_unit: TimeUnit
  hour_unit: TimeUnit
  time_resolution: Tuple[str, TimeUnit]
  x: int
  y: str
  x_unit: str
  y_unit: str
  z: None
  w: int
  u: None
  v: None
  dates: List[date]
}
enum tests.modules.withenum.TimeUnit {
  DAYS: d {static}
  HOURS: h {static}
  MINUTE: m {static}
}
class tests.modules.withinheritancewithinmodule.Animal {
  has_notochord: bool
}
class tests.modules.withinheritancewithinmodule.Fish {
  fins_number: int
}
class tests.modules.withinheritancewithinmodule.GlowingFish {
  glow_for_hunting: bool
  glow_for_mating: bool
}
class tests.modules.withinheritancewithinmodule.Light {
  luminosity_max: float
}
class tests.modules.withnamedtuple.Circle {
  x: Any
  y: Any
  radius: Any
}
class tests.modules.withsubdomain.subdomain.insubdomain.Engine {
  horsepower: int
}
class tests.modules.withsubdomain.subdomain.insubdomain.Pilot {
  name: str
}
class tests.modules.withsubdomain.withsubdomain.Car {
  name: str
  engine: Engine
}
class tests.modules.withwrappedconstructor.Point {
  x: float
  y: float
}
class tests.modules.withwrappedconstructor.PointDecoratedWithoutWrapping {
}
tests.modules.withabstract.ClassTemplate <|-- tests.modules.withabstract.ConcreteClass
tests.modules.withcomposition.Firm *-- tests.modules.withcomposition.Worker
tests.modules.withcomposition.Worker *-- tests.modules.withcomposition.Worker
tests.modules.withcomposition.Worker *-- tests.modules.withcomposition.Address
tests.modules.withcompoundtypewithdigits.Multicast *-- tests.modules.withcompoundtypewithdigits.IPv6
tests.modules.withconstructor.Point *-- tests.modules.withconstructor.Coordinates
tests.modules.withconstructor.Point *-- tests.modules.withenum.TimeUnit
tests.modules.withinheritancewithinmodule.Animal <|-- tests.modules.withinheritancewithinmodule.Fish
tests.modules.withinheritancewithinmodule.Fish <|-- tests.modules.withinheritancewithinmodule.GlowingFish
tests.modules.withinheritancewithinmodule.Light <|-- tests.modules.withinheritancewithinmodule.GlowingFish
tests.modules.withsubdomain.withsubdomain.Car *-- tests.modules.withsubdomain.subdomain.insubdomain.Engine
footer Generated by //py2puml//
@enduml
"""
    assert_py2puml_is_stringio('tests/modules/', 'tests.modules', StringIO(expected))

def test_py2puml_check_if_on_overall_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_check_if_on_overall_returns_iterable(domain_path, domain_module):
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)
    assert all(isinstance(x, str) for x in result)

def test_py2puml_check_if_on_overall_returns_non_null(domain_path, domain_module):
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)

def test_py2puml_on_overall_response_contains_module_name(domain_path, domain_module) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    print(result)
    assert f'@startuml {domain_module}' in "".join(result)
def test_py2puml_contains_module_name_in_response_for_on_overall(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    assert domain_module in "".join(result)

def test_py2puml_creates_namespaces_for_on_overall(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert "namespace" in "".join(result)

def test_py2puml_contains_module_declaration_for_on_overall(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f"@startuml {domain_module}" in "".join(result)

def test_py2puml_contains_inheritance_declaration_for_on_overall(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'<|--' in "".join(result)

def test_py2puml_contains_association_declaration_for_on_overall(domain_path: str, domain_module: str) -> None:
    domain_path = "tests/modules/"
    domain_module = "tests.modules"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'*--' in "".join(result)

@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
)

def test_py2puml_check_if_returns_iterable(domain_path, domain_module):
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, Iterable)
    assert all(isinstance(x, str) for x in result)
    
@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
)
def test_py2puml_returns_iterable(domain_path, domain_module):
    result = py2puml(domain_path, domain_module)
    assert all(isinstance(x, str) for x in result)

@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc'))),
)
def test_py2puml_returns_nonempty_iterable(domain_path, domain_module):
    result = py2puml(domain_path, domain_module)
    assert any(result)

@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd'))),
)
def test_py2puml_returns_valid_puml_content(domain_path, domain_module):
    result = py2puml(domain_path, domain_module)

    # If the result is an object with a 'content' attribute
    if hasattr(result, 'content'):
        result_str = result.content
    else:
        result_str = str(result)

    # Split the result string into individual PUML contents
    puml_contents = result_str.split('@startuml')[1:]

    # Assert that each PUML content is valid
    for content in puml_contents:
        # Remove leading/trailing whitespace and split into lines
        lines = content.strip().split('\n')
        assert len(lines) >= 2
        assert lines[0] == '@startuml'
        assert lines[-1] == '@enduml'

# Test that the function handles special characters in the domain path and module name
@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd')))
)
def test_py2puml_handles_special_characters(domain_path, domain_module):
    result = py2puml(domain_path, domain_module)
    assert isinstance(result, types.GeneratorType)
    assert isinstance(result, types.GeneratorType)
    result_list = list(result)
    assert all(isinstance(x, str) for x in result_list)
    assert len(result_list) > 0
    result_str = "\n".join(result_list)
    assert isinstance(result_str, str)
    assert len(result_str) > 0

# Test that the function returns the same content for the same input
@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd'))),
    domain_module=st.text(min_size=1, alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nd')))
)
def test_py2puml_returns_same_content_for_same_input(domain_path, domain_module):
    result1 = ''.join(py2puml(domain_path, domain_module))
    result2 = ''.join(py2puml(domain_path, domain_module))
    assert result1 == result2

@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(blacklist_categories=('Cc', 'Cs'))),
    domain_module=st.from_regex(r'[a-zA-Z_][a-zA-Z0-9_]*')
)
def test_py2puml_returns_non_empty_puml_content(domain_path: str, domain_module: str) -> None:
    result = list(py2puml(domain_path, domain_module))
    assert isinstance(result, list) and len(result) > 0

# didn't handle utf-8
@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(blacklist_categories=('Cc', 'Cs'))),
    domain_module=st.from_regex(r'[a-zA-Z_][a-zA-Z0-9_]*')
)
def test_py2puml_contains_module_declaration(domain_path: str, domain_module: str) -> None:
    result = py2puml(domain_path, domain_module)
    assert any(f'@startuml {domain_module}' in line for line in result)

@given(st.text(alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc')), min_size=1), st.text(alphabet=st.characters(whitelist_categories=('Lu', 'Ll', 'Nd', 'Pc')), min_size=1))
def test_py2puml_contains_footer(domain_path, domain_module):
    with tempfile.TemporaryDirectory() as tempdir:
        module_name = f'{domain_module}_test_module'
        module_file = Path(tempdir) / f'{module_name}.py'
        module_file.write_text('class MyClass:\n    pass')
        result = list(py2puml(domain_path, module_name))
        assert any('Generated by //py2puml//' in line for line in result)

@given(
    st.text(min_size=1, alphabet=st.characters(blacklist_categories=("Cc", "Cs")), max_size=50).filter(
        lambda s: not any(c in s for c in "/\\:*?\"<>|")
    ),
    st.from_regex(r"[a-zA-Z_][a-zA-Z0-9_]*"),
)
def test_py2puml_contains_module_name(domain_path: str, domain_module: str) -> None:
    result = list(py2puml(domain_path, domain_module))
    print(result)
    assert f'@startuml {domain_module}' in "".join(result)

@given(
    domain_path=st.text(min_size=1, alphabet=st.characters(blacklist_categories=("Cc", "Cs")), max_size=50).filter(
        lambda s: not any(c in s for c in "/\\:*?\"<>|")
    ),
    domain_module=st.from_regex(r"[a-zA-Z_][a-zA-Z0-9_]*"),
)
def test_py2puml_contains_module_name_in_response(domain_path: str, domain_module: str) -> None:
    result = list(py2puml(domain_path, domain_module))
    assert domain_module in "".join(result)

@pytest.fixture
def domain_path():
    return "py2puml/domain"

@pytest.fixture
def domain_module():
    return "py2puml.domain"

def test_py2puml_creates_namespaces(domain_path: str, domain_module: str) -> None:
    domain_path = "py2puml/domain"
    domain_module = "py2puml.domain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert "namespace" in "".join(result)

def test_py2puml_contains_module_declaration(domain_path: str, domain_module: str) -> None:
    domain_path = "py2puml/domain"
    domain_module = "py2puml.domain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f"@startuml {domain_module}" in "".join(result)

def test_py2puml_contains_class_declaration(domain_path: str, domain_module: str) -> None:
    domain_path = "py2puml/domain"
    domain_module = "py2puml.domain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'class ' in "".join(result)

def test_py2puml_contains_inheritance_declaration(domain_path: str, domain_module: str) -> None:
    domain_path = "py2puml/domain"
    domain_module = "py2puml.domain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'<|--' in "".join(result)

def test_py2puml_contains_inheritance_declaration(domain_path: str, domain_module: str) -> None:
    domain_path = "py2puml/domain"
    domain_module = "py2puml.domain"
    result = list(py2puml(domain_path, domain_module))
    print(list(result))
    assert f'*--' in "".join(result)

# Tests for non-existing file path
def test_py2puml_with_non_existing_file_path():
    '''
    Ensures that the py2puml raises an exception for non-existing file path
    '''
    with pytest.raises(FileNotFoundError):
        assert_py2puml_is_file_content('invalid/path', 'invalid', 'invalid.puml')


# Tests for empty folder path
def test_py2puml_with_empty_folder_path():
    '''
    Ensures that the py2puml raises an exception for empty folder path
    '''
    with pytest.raises(FileNotFoundError):
        assert_py2puml_is_file_content('tests/modules/emptyfolder', 'tests.modules.emptyfolder', 'invalid.puml')

# Tests for empty __init__.py file
def test_py2puml_with_empty_init_file():
    '''
    Ensures that the py2puml raises an exception for empty __init__.py file
    '''
    with pytest.raises(Exception):
        assert_py2puml_is_stringio(py2puml('', '__init__'))

def test_zoo():
    expected_output = """@startuml zoo
        namespace zoo.my_module1 {}
        class zoo.my_module1.Animal {
        species: None
        }
        class zoo.my_module1.Cat {
        name: None
        }
        class zoo.my_module1.Dog {
        name: None
        }
        zoo.my_module1.Animal <|-- zoo.my_module1.Cat
        zoo.my_module1.Animal <|-- zoo.my_module1.Dog
        footer Generated by //py2puml//
        @enduml"""
    proc = subprocess.Popen(['py2puml', 'zoo', 'zoo'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_myapp():
    expected_output = """@startuml myapp
                        namespace myapp.my_model {}
                        class myapp.my_model.BlogPost {
                        title: str
                        content: str
                        author: User
                        }
                        class myapp.my_model.User {
                        name: str
                        email: str
                        }
                        myapp.my_model.BlogPost *-- myapp.my_model.User
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'myapp', 'myapp'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_myapp_my_model():
    p = subprocess.run(['py2puml', 'myapp', 'my_model'], capture_output=True, text=True)
    assert p.returncode == 0
    assert 'my_model' in p.stdout

def test_myapp_my_model1():
    p = subprocess.run(['py2puml', 'myapp', 'my_model1'], capture_output=True, text=True)
    assert p.returncode == 0
    assert 'my_model1' in p.stdout

def test_no_input():
    p = subprocess.run(['py2puml'], capture_output=True, text=True)
    assert p.returncode == 2
    assert 'usage: py2puml' in p.stderr
    assert 'error: the following arguments are required: path, module' in p.stderr

#Performance test#
@pytest.mark.benchmark(group="py2puml")
def test_py2puml(benchmark):
    args = ['py2puml', 'py2puml', 'py2puml']
    result = benchmark(subprocess.run, args, capture_output=True, text=True)
    assert result.returncode == 0

@pytest.mark.benchmark(group="py2puml")
def test_small_module(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func(): pass"
    benchmark(py2puml, code, "small.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_10_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func1(): pass\n" * 10
    benchmark(py2puml, code, "module_with_10_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_20_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func1(): pass\n" * 20
    benchmark(py2puml, code, "module_with_20_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_50_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func1(): pass\n" * 50
    benchmark(py2puml, code, "module_with_50_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_100_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func1(): pass\n" * 100
    benchmark(py2puml, code, "module_with_100_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_1000_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func1(): pass\n" * 1000
    benchmark(py2puml, code, "module_with_1000_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_10_classes(benchmark):
    from py2puml.py2puml import py2puml
    code = "class A:\n    pass\n" * 10
    benchmark(py2puml, code, "module_with_10_classes.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_20_classes(benchmark):
    from py2puml.py2puml import py2puml
    code = "class A:\n    pass\n" * 20
    benchmark(py2puml, code, "module_with_20_classes.puml")

@pytest.mark.benchmark(group="py2puml")
def test_module_with_50_classes(benchmark):
    from py2puml.py2puml import py2puml
    code = "class A:\n    pass\n" * 50
    benchmark(py2puml, code, "module_with_50_classes.puml")

@pytest.mark.benchmark(group="py2puml")
def test_long_code(benchmark):
    code = "def func():\n"
    code += "    for i in range(1000):\n"
    code += "        print(i)\n"
    benchmark(py2puml, code, "long_code.puml")

@pytest.mark.benchmark(group="py2puml")
def test_complex_code(benchmark):
    code = "class MyClass:\n"
    code += "    def __init__(self, x):\n"
    code += "        self.x = x\n"
    code += "    def my_method(self, y):\n"
    code += "        if self.x > y:\n"
    code += "            print('x is greater than y')\n"
    code += "        elif self.x < y:\n"
    code += "            print('x is less than y')\n"
    code += "        else:\n"
    code += "            print('x is equal to y')\n"
    benchmark(py2puml, code, "complex_code.puml")

@pytest.mark.benchmark(group="py2puml")
def test_multiline_comments(benchmark):
    code = "\"\"\"\n"
    code += "This is a multiline comment.\n"
    code += "It spans multiple lines.\n"
    code += "It is enclosed in triple quotes.\n"
    code += "\"\"\"\n"
    code += "def func(): pass"
    benchmark(py2puml, code, "multiline_comments.puml")

@pytest.mark.benchmark(group="py2puml")
def test_long_function_name(benchmark):
    code = "def this_is_a_very_long_function_name_that_should_not_be_used_unless_absolutely_necessary(): pass"
    benchmark(py2puml, code, "long_function_name.puml")

@pytest.mark.benchmark(group="py2puml")
def test_nested_functions(benchmark):
    code = "def func1():\n"
    code += "    def func2():\n"
    code += "        def func3():\n"
    code += "            pass\n"
    code += "        func3()\n"
    code += "    func2()\n"
    code += "func1()"
    benchmark(py2puml, code, "nested_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_decorators(benchmark):
    code = "@my_decorator\n"
    code += "def func(): pass\n"
    code += "@my_decorator1\n"
    code += "@my_decorator2\n"
    code += "def func1(): pass"
    benchmark(py2puml, code, "decorators.puml")

def func1():
    pass

def func2():
    pass

def func3():
    pass

def func4():
    pass

code = '''
import numpy as np
import pandas as pd

def func1():
    pass

def func2():
    pass

def func3():
    pass

def func4():
    pass
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_imports_and_functions(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

def func():
    a = np.random.rand(100, 100)
    b = np.random.rand(100, 100)
    c = np.dot(a, b)
    return c

code = '''
import numpy as np
import pandas as pd

def func():
    a = np.random.rand(100, 100)
    b = np.random.rand(100, 100)
    c = np.dot(a, b)
    return c
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_complex_function(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

def func1():
    def func2():
        def func3():
            def func4():
                pass
            pass
        pass
    pass

code = '''
def func1():
    def func2():
        def func3():
            def func4():
                pass
            pass
        pass
    pass
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_nested_functions(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

class MyClass1:
    def __init__(self):
        pass
    
    def method1(self):
        pass

class MyClass2:
    def __init__(self):
        pass
    
    def method2(self):
        pass

class MyClass3:
    def __init__(self):
        pass
    
    def method3(self):
        pass

code = '''
class MyClass1:
    def __init__(self):
        pass
    
    def method1(self):
        pass

class MyClass2:
    def __init__(self):
        pass
    
    def method2(self):
        pass

class MyClass3:
    def __init__(self):
        pass
    
    def method3(self):
        pass
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_classes(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

class MyClass1:
    def __init__(self):
        pass
    
    def method1(self):
        pass

class MyClass2:
    def __init__(self):
        pass
    
    def method2(self):
        pass

class MyClass3:
    def __init__(self):
        pass
    
    def method3(self):
        pass

code = '''
class MyClass1:
    def __init__(self):
        pass
    
    def method1(self):
        pass

class MyClass2:
    def __init__(self):
        pass
    
    def method2(self):
        pass

class MyClass3:
    def __init__(self):
        pass
    
    def method3(self):
        pass
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_classes(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

def my_decorator(func):
    def wrapper():
        print("Before function execution")
        func()
        print("After function execution")
    return wrapper

@my_decorator
def func():
    pass

code = '''
def my_decorator(func):
    def wrapper():
        print("Before function execution")
        func()
        print("After function execution")
    return wrapper

@my_decorator
def func():
    pass
'''

@pytest.mark.benchmark(group="py2puml")
def test_large_module_with_classes(benchmark):
    from py2puml.py2puml import py2puml
    benchmark(py2puml, code, "large.puml")

@pytest.mark.benchmark(group="py2puml")
def test_large_function(benchmark):
    from py2puml.py2puml import py2puml
    code = "def func(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t): pass"
    benchmark(py2puml, code, "large_function.puml")

@pytest.mark.benchmark(group="py2puml")
def test_large_class(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class MyClass:
        def __init__(self, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t):
            self.a = a
            self.b = b
            self.c = c
            self.d = d
            self.e = e
            self.f = f
            self.g = g
            self.h = h
            self.i = i
            self.j = j
            self.k = k
            self.l = l
            self.m = m
            self.n = n
            self.o = o
            self.p = p
            self.q = q
            self.r = r
            self.s = s
            self.t = t
        def method1(self):
            pass
        def method2(self):
            pass
    """
    benchmark(py2puml, code, "large_class.puml")

@pytest.mark.benchmark(group="py2puml")
def test_nested_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    def outer():
        def inner():
            pass
        inner()
    """
    benchmark(py2puml, code, "nested_functions.puml")

@pytest.mark.benchmark(group="py2puml")
def test_nested_classes(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class Outer:
        def __init__(self):
            self.inner = self.Inner()
        class Inner:
            def method1(self):
                pass
            def method2(self):
                pass
    """
    benchmark(py2puml, code, "nested_classes.puml")

@pytest.mark.benchmark(group="py2puml")
def test_simple_generator(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    def my_generator():
        for i in range(10):
            yield i
    """
    benchmark(py2puml, code, "simple_generator.puml")

@pytest.mark.benchmark(group="py2puml")
def test_complex_generator(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    def my_generator():
        for i in range(10):
            def inner():
                pass
            yield inner
    """
    benchmark(py2puml, code, "complex_generator.puml")

@pytest.mark.benchmark(group="py2puml")
def test_list_comprehension(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    my_list = [i for i in range(10)]
    """
    benchmark(py2puml, code, "list_comprehension.puml")

@pytest.mark.benchmark(group="py2puml")
def test_medium_module(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        import numpy as np

        def compute_mean(numbers):
            return np.mean(numbers)

        if __name__ == '__main__':
            numbers = [1, 2, 3, 4, 5]
            mean = compute_mean(numbers)
            print(f'The mean of {numbers} is {mean}')
    """
    benchmark(py2puml, code, "medium.puml")

@pytest.mark.benchmark(group="py2puml")
def test_large_module(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        import random
        import string

        def generate_password(length):
            return ''.join(random.choice(string.ascii_letters) for _ in range(length))

        class User:
            def __init__(self, username, email):
                self.username = username
                self.email = email

            def reset_password(self):
                new_password = generate_password(8)
                print(f'New password generated: {new_password}')

        if __name__ == '__main__':
            user1 = User('john.doe', 'john.doe@example.com')
            user1.reset_password()
    """
    benchmark(py2puml, code, "large.puml")

@pytest.mark.benchmark(group="py2puml")
def test_simple_function(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        def add(a, b):
            return a + b
    """
    benchmark(py2puml, code, "simple.puml")

@pytest.mark.benchmark(group="py2puml")
def test_class_with_methods(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class Calculator:
            def add(self, a, b):
                return a + b

            def subtract(self, a, b):
                return a - b

            def multiply(self, a, b):
                return a * b

            def divide(self, a, b):
                return a / b if b != 0 else None
    """
    benchmark(py2puml, code, "class.puml")

@pytest.mark.benchmark(group="py2puml")
def test_class_hierarchy(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class Animal:
            def __init__(self, name, sound):
                self.name = name
                self.sound = sound

            def make_sound(self):
                print(self.sound)

        class Cat(Animal):
            def __init__(self, name):
                super().__init__(name, 'Meow')

        class Dog(Animal):
            def __init__(self, name):
                super().__init__(name, 'Woof')

        if __name__ == '__main__':
            cat = Cat('Whiskers')
            dog = Dog('Fido')
            cat.make_sound()
            dog.make_sound()
    """
    benchmark(py2puml, code, "animals.puml")
@pytest.mark.benchmark(group="py2puml")
def test_recursive_function(benchmark):
    code = """
    def factorial(n):
        if n == 1:
            return 1
        else:
            return n * factorial(n-1)
    """
    benchmark(py2puml, code, "recursive.puml")

@pytest.mark.benchmark(group="py2puml")
def test_lambda_function(benchmark):
    code = """
    double = lambda x: x * 2
    """
    benchmark(py2puml, code, "lambda.puml")

@pytest.mark.benchmark(group="py2puml")
def test_dict_comprehension(benchmark):
    code = """
    {x: x**2 for x in (2, 4, 6)}
    """
    benchmark(py2puml, code, "dict_comprehension.puml")

@pytest.mark.benchmark(group="py2puml")
def test_set_comprehension(benchmark):
    code = """
    {x for x in 'abracadabra' if x not in 'abc'}
    """
    benchmark(py2puml, code, "set_comprehension.puml")

@pytest.mark.benchmark(group="py2puml")
def test_large_attributes(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class MyClass:
            def __init__(self):
                self.attr1 = 1
                self.attr2 = 2
                self.attr3 = 3
                self.attr4 = 4
                self.attr5 = 5
                self.attr6 = 6
                self.attr7 = 7
                self.attr8 = 8
                self.attr9 = 9
                self.attr10 = 10
    """
    benchmark(py2puml, code, "large_attributes.puml")

@pytest.mark.benchmark(group="py2puml")
def test_large_attributes(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class MyClass:
            def __init__(self):
                self.attr1 = 1
                self.attr2 = 2
                self.attr3 = 3
                self.attr4 = 4
                self.attr5 = 5
                self.attr6 = 6
                self.attr7 = 7
                self.attr8 = 8
                self.attr9 = 9
                self.attr10 = 10
    """
    benchmark(py2puml, code, "large_attributes.puml")

# Test case for measuring the performance of generating a UML class diagram for a large module
@pytest.mark.benchmark(group="py2puml")
def test_large_module(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class MyClass:
            def __init__(self, x):
                self.x = x
        
            def increment(self):
                self.x += 1
    """
    benchmark(py2puml, code, "large.puml")

# Test case for measuring the performance of generating a UML class diagram for a module with multiple classes
@pytest.mark.benchmark(group="py2puml")
def test_multiple_classes(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        class MyClass:
            def __init__(self, x):
                self.x = x
        
            def increment(self):
                self.x += 1

        class MyOtherClass:
            def __init__(self, y):
                self.y = y
        
            def decrement(self):
                self.y -= 1
    """
    benchmark(py2puml, code, "multiple_classes.puml")

# Test case for measuring the performance of generating a UML class diagram for a module with a large number of functions
@pytest.mark.benchmark(group="py2puml")
def test_many_functions(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        def func1():
            pass

        def func2():
            pass

        def func3():
            pass

        def func4():
            pass

        def func5():
            pass

        def func6():
            pass

        def func7():
            pass

        def func8():
            pass

        def func9():
            pass

        def func10():
            pass

        def func11():
            pass

        def func12():
            pass

        def func13():
            pass

        def func14():
            pass

        def func15():
            pass

        def func16():
            pass

        def func17():
            pass

        def func18():
            pass

        def func19():
            pass

        def func20():
            pass
    """
    benchmark(py2puml, code, "many_functions.puml")

# Test case for measuring the performance of generating a UML class diagram for a module with a large number of variables
@pytest.mark.benchmark(group="py2puml")
def test_many_variables(benchmark):
    from py2puml.py2puml import py2puml
    code = """
        var1 = 1
        var2 = 2
        var3 = 3
        var4 = 4
        var5 = 5
        var6 = 6
        var7 = 7
        var8 = 8
        var9 = 9
        var10 = 10
        var11 = 11
        var12 = 12
        var13 = 13
        var14 = 14
        var15 = 15
        var16 = 16
        var17 = 17
        var18 = 18
        var19 = 19
        var20 = 20
    """
    benchmark(py2puml, code, "many_variables.puml")

@pytest.mark.benchmark(group="py2puml")
def test_many_comments(benchmark):
    from py2puml.py2puml import py2puml

    code = """
    # This is a sample code with many comments
    # Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    # Phasellus posuere, felis eget dictum placerat, velit magna finibus nunc,
    # vitae varius urna elit sit amet dolor.
    # Praesent at urna vel tellus sollicitudin laoreet non non dui.
    # Pellentesque sollicitudin nulla in nunc posuere, sed lacinia sapien venenatis.
    # Sed rhoncus purus ut turpis rutrum, in convallis ex maximus.
    def func():
        # This is a sample function with many comments
        # Aliquam semper ligula sed ex lobortis, at auctor velit hendrerit.
        # Pellentesque ornare pharetra leo vel sollicitudin.
        # Etiam auctor, nisi ac interdum tincidunt, purus libero dapibus ipsum,
        # nec dictum massa quam eu turpis.
        pass

    # Class with many comments
    class MyClass(object):
        # This is a sample class with many comments
        # Fusce id quam vitae massa blandit consequat at ac massa.
        # Donec vulputate nisi ac enim facilisis lobortis.
        # Aliquam at tempor velit, id eleifend nunc.
        # Nullam a pharetra orci, sed efficitur odio.
        # Nam at lorem at nibh sollicitudin hendrerit eu a est.
        # Vestibulum vitae sagittis velit.
        def method(self):
            # This is a sample method with many comments
            # Sed congue arcu id augue congue porttitor.
            # Sed nec elementum mi, ut ultricies nibh.
            # Fusce vestibulum vel nisi eu suscipit.
            pass
    """

    benchmark(py2puml, code, "many_comments.puml")

def test_simple_class_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class MyClass:
        def my_method(self):
            pass
    """
    benchmark(py2puml, code, "class.puml")

def test_sequence_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    def func():
        pass
    
    func()
    """
    benchmark(py2puml, code, "sequence.puml")

def test_state_machine_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class MyClass:
        def __init__(self):
            self.state = "INITIAL"
        
        def run(self):
            self.state = "RUNNING"
        
        def stop(self):
            self.state = "STOPPED"
    """
    benchmark(py2puml, code, "state_machine.puml")

def test_activity_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    def func(x):
        if x > 0:
            print("Positive")
        else:
            print("Non-positive")
    """
    benchmark(py2puml, code, "activity.puml")

def test_deployment_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class Server1:
        pass
    
    class Server2:
        pass
    
    class Node1:
        pass
    
    class Node2:
        pass
    """
    benchmark(py2puml, code, "deployment.puml")

def test_component_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class Database:
        pass
    
    class Backend:
        pass
    
    class Frontend:
        pass
    """
    benchmark(py2puml, code, "component.puml")

def test_use_case_diagram(benchmark):
    from py2puml.py2puml import py2puml
    code = """
    class Actor1:
        pass
    
    class Actor2:
        pass
    
    class UseCase1:
        pass
    
    class UseCase2:
        pass
    """
    benchmark(py2puml, code, "use_case.puml")

#### Performance testing ends ####

def test_py2puml_generates_extension_notations() -> None:
    expected_output = "smd.fan.Class10 *-- smd.fan.Class05"
    proc = subprocess.Popen(['py2puml', 'smd', 'smd'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_generates_aggregation_notations() -> None:
    expected_output = "smd.fan.Employee *-- smd.fan.Department"
    proc = subprocess.Popen(['py2puml', 'smd', 'smd'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_generates_composition_notations() -> None:
    expected_output = "smd.fan.Class10 *-- smd.fan.Class05"
    proc = subprocess.Popen(['py2puml', 'smd', 'smd'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_empty_class() -> None:
    expected_output = """@startuml emptyclass
namespace emptyclass.my_module {}
class emptyclass.my_module.MyClass {
}
footer Generated by //py2puml//
@enduml"""
    proc = subprocess.Popen(['py2puml', 'emptyclass', 'emptyclass'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_basic_class() -> None:
    expected_output = """@startuml basicclass
                        namespace basicclass.fan {}
                        class basicclass.fan.MyClass {
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'basicclass', 'basicclass'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_attribute() -> None:
    expected_output = """@startuml classwithattribute
                            namespace classwithattribute.my_module {}
                            class classwithattribute.my_module.MyClass {
                            attribute1: str
                            attribute2: int
                            }
                            footer Generated by //py2puml//
                            @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithattribute', 'classwithattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_constructor() -> None:
    expected_output = """@startuml checkconstructor
                        namespace checkconstructor.my_module {}
                        class checkconstructor.my_module.Coordinates {
                        x: float
                        y: float
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkconstructor', 'checkconstructor'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_inheritance() -> None:
    expected_output = """@startuml checkconstructor
                        namespace checkconstructor.my_module {}
                        class checkconstructor.my_module.Coordinates {
                        x: float
                        y: float
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkinheritance', 'checkinheritance'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_multi_inheritance() -> None:
    expected_output = """@startuml checkmultiinheritance
                        namespace checkmultiinheritance.my_module {}
                        class checkmultiinheritance.my_module.Child {
                        }
                        class checkmultiinheritance.my_module.Parent1 {
                        }
                        class checkmultiinheritance.my_module.Parent2 {
                        }
                        checkmultiinheritance.my_module.Parent1 <|-- checkmultiinheritance.my_module.Child
                        checkmultiinheritance.my_module.Parent2 <|-- checkmultiinheritance.my_module.Child
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkmultiinheritance', 'checkmultiinheritance'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_static_attribute() -> None:
    expected_output = """@startuml checkstaticattribute
                        namespace checkstaticattribute.my_module {}
                        class checkstaticattribute.my_module.MyClass {
                        attribute1: str {static}
                        attribute2: int {static}
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkstaticattribute', 'checkstaticattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_docsstring() -> None:
    expected_output = """@startuml checkdocstring
                        namespace checkdocstring.my_module {}
                        class checkdocstring.my_module.MyClass {
                        attribute1: str {static}
                        attribute2: int {static}
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkdocstring', 'checkdocstring'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_single_decorator() -> None:
    expected_output = """@startuml checkdecorator
                        namespace checkdecorator.my_module {}
                        class checkdecorator.my_module.NewClass {
                        }
                        checkdecorator.my_module.MyClass <|-- checkdecorator.my_module.NewClass
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'checkdecorator', 'checkdecorator'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_private_attribute() -> None:
    expected_output = """@startuml privateattribute
                        namespace privateattribute.my_module {}
                        class privateattribute.my_module.MyClass {
                        __attribute: str
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'privateattribute', 'privateattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_protected_attribute() -> None:
    expected_output = """@startuml protectedattribute
                        namespace protectedattribute.my_module {}
                        class protectedattribute.my_module.MyClass {
                        _attribute: str
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'protectedattribute', 'protectedattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_default_attribute() -> None:
    expected_output = """@startuml defaultattribute
                        namespace defaultattribute.my_module {}
                        class defaultattribute.my_module.MyClass {
                        attribute: str
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'defaultattribute', 'defaultattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_multiple_attributes() -> None:
    expected_output = """@startuml multipleattribute
                        namespace multipleattribute.my_module {}
                        class multipleattribute.my_module.MyClass {
                        attribute1: str
                        attribute2: int
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'multipleattribute', 'multipleattribute'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_multiple_attributes_and_constructor() -> None:
    expected_output = """@startuml multipleattribute
                        namespace multipleattribute.my_module {}
                        class multipleattribute.my_module.MyClass {
                        attribute1: str
                        attribute2: int
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'multipleattributeandconstructor', 'multipleattributeandconstructor'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_single_inheritance() -> None:
    expected_output = """@startuml singleinheritance
                        namespace singleinheritance.my_module {}
                        class singleinheritance.my_module.Child {
                        }
                        class singleinheritance.my_module.Parent {
                        }
                        singleinheritance.my_module.Parent <|-- singleinheritance.my_module.Child
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'singleinheritance', 'singleinheritance'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_multiple_inheritance() -> None:
    expected_output = """@startuml multipleinheritance
                        namespace multipleinheritance.my_module {}
                        class multipleinheritance.my_module.Child {
                        }
                        class multipleinheritance.my_module.Parent1 {
                        }
                        class multipleinheritance.my_module.Parent2 {
                        }
                        multipleinheritance.my_module.Parent1 <|-- multipleinheritance.my_module.Child
                        multipleinheritance.my_module.Parent2 <|-- multipleinheritance.my_module.Child
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'multipleinheritance', 'multipleinheritance'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_property() -> None:
    expected_output = """@startuml classwithproperty
                        namespace classwithproperty.my_module {}
                        class classwithproperty.my_module.MyClass {
                        _property1: None
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithproperty', 'classwithproperty'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_multilpe_decorators() -> None:
    expected_output = """@startuml classwithmultipledecorators
                        namespace classwithmultipledecorators.my_module {}
                        class classwithmultipledecorators.my_module.NewClass1 {
                        }
                        classwithmultipledecorators.my_module.NewClass2 <|-- classwithmultipledecorators.my_module.NewClass1
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithmultipledecorators', 'classwithmultipledecorators'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_property_decorator() -> None:
    expected_output = """@startuml classwithpropertydecorator
                        namespace classwithpropertydecorator.my_module {}
                        class classwithpropertydecorator.my_module.MyClass {
                        _attribute1: str
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithpropertydecorator', 'classwithpropertydecorator'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_class_method() -> None:
    expected_output = """@startuml classwithclassmethod
                        namespace classwithclassmethod.my_module {}
                        class classwithclassmethod.my_module.Foo {
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithclassmethod', 'classwithclassmethod'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output

def test_py2puml_class_with_inner_class() -> None:
    expected_output = """@startuml classwithinnerclass
                        namespace classwithinnerclass.my_module {}
                        class classwithinnerclass.my_module.Foo {
                        }
                        footer Generated by //py2puml//
                        @enduml"""
    proc = subprocess.Popen(['py2puml', 'classwithinnerclass', 'classwithinnerclass'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=-1)
    out, err = proc.communicate()
    output = out.decode()
    assert output, expected_output